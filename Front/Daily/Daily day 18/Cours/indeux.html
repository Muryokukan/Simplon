<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>JavaScript POO - Guide Junior</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            line-height: 1.6;
            color: #333;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding-left: 15vw;
            padding-right: 15vw;
        }
        
        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
            background: white;
            margin-top: 20px;
            margin-bottom: 20px;
            border-radius: 10px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.3);
        }
        
        h1 {
            text-align: center;
            color: #2c3e50;
            margin-bottom: 30px;
            font-size: 2.5em;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.1);
        }
        
        h2 {
            color: #34495e;
            border-left: 5px solid #3498db;
            padding-left: 15px;
            margin-top: 30px;
            margin-bottom: 20px;
            font-size: 1.8em;
        }
        
        h3 {
            color: #2980b9;
            margin-top: 20px;
            margin-bottom: 15px;
            font-size: 1.4em;
        }
        
        h4 {
            color: #27ae60;
            margin-top: 15px;
            margin-bottom: 10px;
            font-size: 1.2em;
        }
        
        p {
            margin-bottom: 15px;
            text-align: justify;
        }
        
        .code-block {
            background: #2c3e50;
            color: #ecf0f1;
            padding: 20px;
            border-radius: 8px;
            margin: 15px 0;
            overflow-x: auto;
            font-family: 'Courier New', monospace;
            border-left: 5px solid #e74c3c;
        }
        
        .highlight {
            background: #f39c12;
            color: white;
            padding: 3px 6px;
            border-radius: 3px;
            font-weight: bold;
        }
        
        .important {
            background: #e8f5e8;
            border-left: 5px solid #27ae60;
            padding: 15px;
            margin: 15px 0;
            border-radius: 5px;
        }
        
        .warning {
            background: #fff3cd;
            border-left: 5px solid #ffc107;
            padding: 15px;
            margin: 15px 0;
            border-radius: 5px;
        }
        
        ul {
            margin: 15px 0;
            padding-left: 30px;
        }
        
        li {
            margin-bottom: 8px;
        }
        
        .nav {
            background: #34495e;
            padding: 15px;
            border-radius: 8px;
            margin-bottom: 30px;
        }
        
        .nav a {
            color: #ecf0f1;
            text-decoration: none;
            margin-right: 20px;
            padding: 5px 10px;
            border-radius: 5px;
            transition: background 0.3s;
        }
        
        .nav a:hover {
            background: #2c3e50;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>ğŸš€ JavaScript POO - Guide pour Junior DÃ©veloppeur</h1>
        
        <nav class="nav">
            <a href="#intro">Introduction</a>
            <a href="#classes">Classes</a>
            <a href="#encapsulation">Encapsulation</a>
            <a href="#heritage">HÃ©ritage</a>
            <a href="#polymorphisme">Polymorphisme</a>
            <a href="#relations">Relations</a>
        </nav>

        <section id="intro">
            <h2>ğŸ¤” Est-ce que JavaScript est un langage OrientÃ© Objet ?</h2>
            
            <div class="important">
                <p><strong>RÃ©ponse courte :</strong> Oui et non ! JavaScript est un langage <span class="highlight">multi-paradigme</span> qui supporte la POO, mais d'une maniÃ¨re diffÃ©rente des langages comme Java ou C#.</p>
            </div>

            <p>JavaScript utilise un systÃ¨me de <strong>prototypes</strong> plutÃ´t qu'un systÃ¨me de classes traditionnel (mÃªme si ES6 a introduit la syntaxe des classes). Cela signifie que :</p>
            
            <ul>
                <li>âœ… On peut crÃ©er des objets</li>
                <li>âœ… On peut utiliser l'hÃ©ritage</li>
                <li>âœ… On peut encapsuler des donnÃ©es</li>
                <li>âœ… On peut implÃ©menter le polymorphisme</li>
            </ul>

            <h3>ğŸ¯ Qu'est-ce que l'Abstraction ?</h3>
            <p>L'abstraction consiste Ã  <strong>simplifier la complexitÃ©</strong> en cachant les dÃ©tails d'implÃ©mentation et en exposant seulement les fonctionnalitÃ©s essentielles.</p>
            
            <div class="code-block">
// Exemple d'abstraction
class Voiture {
    constructor(marque, modele) {
        this.marque = marque;
        this.modele = modele;
        this.moteurDemarre = false;
    }
    
    // MÃ©thode abstraite - on cache la complexitÃ© du dÃ©marrage
    demarrer() {
        // ComplexitÃ© cachÃ©e : injection carburant, allumage, etc.
        this.moteurDemarre = true;
        console.log("ğŸš— La voiture a dÃ©marrÃ© !");
    }
    
    // L'utilisateur n'a pas besoin de connaÃ®tre le processus interne
    conduire() {
        if (this.moteurDemarre) {
            console.log("ğŸï¸ Vrooom !");
        } else {
            console.log("âŒ DÃ©marrez d'abord la voiture !");
        }
    }
}
            </div>
        </section>

        <section id="classes">
            <h2>ğŸ—ï¸ Les Classes en JavaScript</h2>
            
            <h3>ğŸ§± Qu'est-ce qu'une Classe ?</h3>
            <p>Une classe est un <span class="highlight">modÃ¨le</span> ou un <span class="highlight">blueprint</span> qui dÃ©finit les propriÃ©tÃ©s et mÃ©thodes que doivent avoir les objets crÃ©Ã©s Ã  partir de cette classe.</p>

            <h3>ğŸ†š Classes ConcrÃ¨tes vs Abstraites</h3>
            
            <h4>Classes ConcrÃ¨tes :</h4>
            <ul>
                <li>Peuvent Ãªtre <strong>instanciÃ©es</strong> directement</li>
                <li>Toutes leurs mÃ©thodes sont implÃ©mentÃ©es</li>
            </ul>
            
            <h4>Classes Abstraites :</h4>
            <div class="warning">
                <p><strong>Note :</strong> JavaScript ne supporte pas nativement les classes abstraites, mais on peut les simuler.</p>
            </div>
            
            <div class="code-block">
// Simulation d'une classe abstraite
class Animal {
    constructor(nom) {
        if (this.constructor === Animal) {
            throw new Error("Classe abstraite - ne peut pas Ãªtre instanciÃ©e");
        }
        this.nom = nom;
    }
    
    // MÃ©thode abstraite (doit Ãªtre redÃ©finie)
    faireBruit() {
        throw new Error("MÃ©thode abstraite - doit Ãªtre implÃ©mentÃ©e");
    }
}

// Classe concrÃ¨te
class Chien extends Animal {
    faireBruit() {
        return "Woof! ğŸ•";
    }
}
            </div>

            <h3>ğŸ”§ Le Constructeur</h3>
            <p>Le constructeur est une <strong>mÃ©thode spÃ©ciale</strong> qui s'exÃ©cute automatiquement lors de la crÃ©ation d'un objet.</p>
            
            <div class="code-block">
class Personne {
    constructor(nom, age) {
        // Initialisation des propriÃ©tÃ©s
        this.nom = nom;
        this.age = age;
        this.dateCreation = new Date();
        console.log(`âœ¨ Nouvelle personne crÃ©Ã©e : ${nom}`);
    }
}

const alice = new Personne("Alice", 25);
            </div>

            <h3>ğŸ“¦ Attributs/PropriÃ©tÃ©s</h3>
            <p>Les propriÃ©tÃ©s sont les <strong>variables</strong> qui appartiennent Ã  un objet et stockent son Ã©tat.</p>
            
            <div class="code-block">
class Smartphone {
    constructor(marque, modele) {
        // PropriÃ©tÃ©s publiques
        this.marque = marque;
        this.modele = modele;
        this.batterie = 100;
        
        // PropriÃ©tÃ© privÃ©e (ES2022)
        #numeroSerie = this.genererNumeroSerie();
    }
    
    genererNumeroSerie() {
        return Math.random().toString(36).substr(2, 9);
    }
}
            </div>

            <h3>âš¡ MÃ©thodes</h3>
            <p>Les mÃ©thodes sont des <strong>fonctions</strong> qui appartiennent Ã  un objet et dÃ©finissent son comportement.</p>

            <h4>ğŸ”„ DiffÃ©rence avec les fonctions :</h4>
            <ul>
                <li><strong>Fonction :</strong> Code indÃ©pendant, rÃ©utilisable</li>
                <li><strong>MÃ©thode :</strong> Fonction liÃ©e Ã  un objet, accÃ¨de Ã  ses propriÃ©tÃ©s via <code>this</code></li>
            </ul>

            <div class="code-block">
// Fonction indÃ©pendante
function calculerAge(dateNaissance) {
    return new Date().getFullYear() - dateNaissance.getFullYear();
}

// MÃ©thode dans une classe
class Utilisateur {
    constructor(nom, dateNaissance) {
        this.nom = nom;
        this.dateNaissance = dateNaissance;
    }
    
    // MÃ©thode - a accÃ¨s aux propriÃ©tÃ©s de l'objet
    calculerAge() {
        return new Date().getFullYear() - this.dateNaissance.getFullYear();
    }
    
    sePresenter() {
        return `Salut, je suis ${this.nom} et j'ai ${this.calculerAge()} ans!`;
    }
}
            </div>

            <h3>ğŸ­ Getters et Setters</h3>
            <p>Les getters et setters permettent de <strong>contrÃ´ler l'accÃ¨s</strong> aux propriÃ©tÃ©s d'un objet.</p>
            
            <div class="code-block">
class Temperature {
    constructor(celsius = 0) {
        this._celsius = celsius;
    }
    
    // Getter - rÃ©cupÃ¨re une valeur
    get celsius() {
        return this._celsius;
    }
    
    // Setter - dÃ©finit une valeur avec validation
    set celsius(value) {
        if (value < -273.15) {
            throw new Error("TempÃ©rature impossible (en dessous du zÃ©ro absolu)");
        }
        this._celsius = value;
    }
    
    // Getter calculÃ©
    get fahrenheit() {
        return (this._celsius * 9/5) + 32;
    }
    
    set fahrenheit(value) {
        this._celsius = (value - 32) * 5/9;
    }
}

const temp = new Temperature();
temp.celsius = 25;
console.log(temp.fahrenheit); // 77
            </div>

            <h3>ğŸ­ Principe d'Instance</h3>
            <p>Une instance est un <strong>objet concret</strong> crÃ©Ã© Ã  partir d'une classe. Chaque instance a ses propres propriÃ©tÃ©s tout en partageant les mÃ©thodes de la classe.</p>
            
            <div class="code-block">
class CompteBancaire {
    constructor(titulaire, soldeInitial = 0) {
        this.titulaire = titulaire;
        this.solde = soldeInitial;
        this.id = Date.now() + Math.random();
    }
}

// CrÃ©ation de plusieurs instances
const compteAlice = new CompteBancaire("Alice", 1000);
const compteBob = new CompteBancaire("Bob", 500);

console.log(compteAlice.titulaire); // "Alice"
console.log(compteBob.titulaire);   // "Bob"
// Chaque instance est unique !
            </div>
        </section>

        <section id="encapsulation">
            <h2>ğŸ”’ Encapsulation</h2>
            
            <h3>ğŸ¯ Qu'est-ce que l'Encapsulation ?</h3>
            <p>L'encapsulation consiste Ã  <span class="highlight">regrouper les donnÃ©es et les mÃ©thodes</span> dans une classe et Ã  <span class="highlight">contrÃ´ler l'accÃ¨s</span> Ã  ces donnÃ©es.</p>
            
            <h3>ğŸ’¡ Ã€ quoi sert l'Encapsulation ?</h3>
            <ul>
                <li>ğŸ›¡ï¸ <strong>ProtÃ©ger les donnÃ©es</strong> contre les modifications non autorisÃ©es</li>
                <li>ğŸ¯ <strong>Simplifier l'interface</strong> en cachant la complexitÃ© interne</li>
                <li>ğŸ”§ <strong>Faciliter la maintenance</strong> du code</li>
                <li>ğŸ› <strong>RÃ©duire les bugs</strong> en contrÃ´lant les accÃ¨s</li>
            </ul>

            <h3>ğŸ”‘ Mots-clÃ©s pour l'Encapsulation</h3>
            
            <div class="important">
                <p><strong>En JavaScript (ES2022+) :</strong></p>
                <ul>
                    <li><code>#</code> - PropriÃ©tÃ©s/mÃ©thodes privÃ©es</li>
                    <li><code>public</code> - Par dÃ©faut (pas de mot-clÃ©)</li>
                </ul>
            </div>
            
            <div class="code-block">
class Coffret {
    // PropriÃ©tÃ© privÃ©e
    #code;
    #contenu;
    
    constructor(code) {
        this.#code = code;
        this.#contenu = [];
        this.verrouille = true;
    }
    
    // MÃ©thode privÃ©e
    #verifierCode(codeTest) {
        return this.#code === codeTest;
    }
    
    // MÃ©thodes publiques
    ouvrir(code) {
        if (this.#verifierCode(code)) {
            this.verrouille = false;
            return "ğŸ”“ Coffret ouvert !";
        } else {
            return "âŒ Code incorrect !";
        }
    }
    
    ajouterObjet(objet, code) {
        if (!this.verrouille) {
            this.#contenu.push(objet);
            return `âœ… ${objet} ajoutÃ© au coffret`;
        }
        return "ğŸ”’ Coffret verrouillÃ© !";
    }
}

const monCoffret = new Coffret("1234");
// monCoffret.#code; // âŒ Erreur ! PropriÃ©tÃ© privÃ©e
console.log(monCoffret.ouvrir("1234")); // âœ… Fonctionne
            </div>

            <h3>ğŸŒ Principe de Scope (PortÃ©e)</h3>
            <p>Le scope dÃ©termine <strong>oÃ¹</strong> dans le code une variable ou mÃ©thode peut Ãªtre utilisÃ©e.</p>
            
            <div class="code-block">
class ExempleScope {
    constructor() {
        this.publique = "Accessible partout"; // Scope : public
        this.#privee = "Accessible seulement dans la classe"; // Scope : privÃ©
    }
    
    methodePublique() {
        // Peut accÃ©der aux deux
        console.log(this.publique);
        console.log(this.#privee);
        
        // Variable locale
        let locale = "Accessible seulement dans cette mÃ©thode";
        console.log(locale);
    }
}
            </div>
            
            <div class="important">
                <p><strong>Pourquoi le scope est fondamental en POO :</strong></p>
                <ul>
                    <li>ğŸ¯ ContrÃ´le l'accÃ¨s aux donnÃ©es</li>
                    <li>ğŸ›¡ï¸ Ã‰vite les conflits de noms</li>
                    <li>ğŸ”’ Garantit la sÃ©curitÃ© des donnÃ©es</li>
                    <li>ğŸ“ Rend le code plus lisible et maintenable</li>
                </ul>
            </div>
        </section>

        <section id="heritage">
            <h2>ğŸ‘¨â€ğŸ‘©â€ğŸ‘§â€ğŸ‘¦ HÃ©ritage</h2>
            
            <h3>ğŸ¯ Ã€ quoi sert l'HÃ©ritage ?</h3>
            <p>L'hÃ©ritage permet Ã  une classe d'<strong>hÃ©riter</strong> des propriÃ©tÃ©s et mÃ©thodes d'une autre classe, favorisant la <span class="highlight">rÃ©utilisation du code</span> et Ã©tablissant des relations hiÃ©rarchiques.</p>
            
            <h3>âœï¸ Comment Ã©crit-on l'HÃ©ritage ?</h3>
            <p>En JavaScript, on utilise le mot-clÃ© <code>extends</code> et <code>super</code>.</p>
            
            <div class="code-block">
// Classe parente (superclasse)
class Vehicule {
    constructor(marque, modele, annee) {
        this.marque = marque;
        this.modele = modele;
        this.annee = annee;
        this.vitesse = 0;
    }
    
    accelerer(increment = 10) {
        this.vitesse += increment;
        console.log(`ğŸš€ Vitesse: ${this.vitesse} km/h`);
    }
    
    freiner() {
        this.vitesse = Math.max(0, this.vitesse - 15);
        console.log(`ğŸ›‘ Vitesse: ${this.vitesse} km/h`);
    }
    
    getInfo() {
        return `${this.marque} ${this.modele} (${this.annee})`;
    }
}

// Classe enfant (sous-classe)
class Voiture extends Vehicule {
    constructor(marque, modele, annee, nombrePortes) {
        // Appel du constructeur parent
        super(marque, modele, annee);
        this.nombrePortes = nombrePortes;
        this.climatisation = false;
    }
    
    // MÃ©thode spÃ©cifique Ã  Voiture
    activerClimatisation() {
        this.climatisation = !this.climatisation;
        console.log(`â„ï¸ Climatisation: ${this.climatisation ? 'ON' : 'OFF'}`);
    }
    
    // RedÃ©finition (override) d'une mÃ©thode hÃ©ritÃ©e
    getInfo() {
        return `${super.getInfo()} - ${this.nombrePortes} portes`;
    }
}

// Autre classe enfant
class Moto extends Vehicule {
    constructor(marque, modele, annee, cylindree) {
        super(marque, modele, annee);
        this.cylindree = cylindree;
    }
    
    // RedÃ©finition avec comportement diffÃ©rent
    accelerer(increment = 20) {
        super.accelerer(increment);
        console.log("ğŸï¸ Vrooooom !");
    }
}

// Utilisation
const maVoiture = new Voiture("Toyota", "Prius", 2023, 4);
const maMoto = new Moto("Yamaha", "R1", 2023, 1000);

maVoiture.accelerer(); // HÃ©rite de Vehicule
maVoiture.activerClimatisation(); // MÃ©thode propre Ã  Voiture

maMoto.accelerer(); // Comportement redÃ©fini
            </div>

            <h3>ğŸ¤” Dans quel cas utilise-t-on l'HÃ©ritage ?</h3>
            <ul>
                <li>ğŸ“Š <strong>Relation "est-un"</strong> : Un chien EST un animal</li>
                <li>ğŸ”„ <strong>Code rÃ©pÃ©titif</strong> : Plusieurs classes partagent des propriÃ©tÃ©s communes</li>
                <li>ğŸ—ï¸ <strong>HiÃ©rarchie naturelle</strong> : Structure logique parent-enfant</li>
                <li>ğŸ¯ <strong>SpÃ©cialisation</strong> : Ajouter des fonctionnalitÃ©s spÃ©cifiques</li>
            </ul>

            <h3>ğŸ‘¨â€ğŸ‘§ Relations Parent â†’ Enfant</h3>
            <div class="important">
                <p><strong>L'enfant hÃ©rite du parent :</strong></p>
                <ul>
                    <li>âœ… Toutes les propriÃ©tÃ©s publiques</li>
                    <li>âœ… Toutes les mÃ©thodes publiques</li>
                    <li>âœ… Peut redÃ©finir les mÃ©thodes (override)</li>
                    <li>âœ… Peut ajouter ses propres propriÃ©tÃ©s/mÃ©thodes</li>
                </ul>
            </div>

            <h3>ğŸ‘§â€ğŸ‘¨ Relations Enfant â†’ Parent</h3>
            <div class="code-block">
class Animal {
    constructor(nom) {
        this.nom = nom;
    }
    
    dormir() {
        console.log(`${this.nom} dort...  ğŸ˜´`);
    }
}

class Chat extends Animal {
    constructor(nom, race) {
        super(nom); // Appel explicite au parent
        this.race = race;
    }
    
    miauler() {
        super.dormir(); // Utilise la mÃ©thode du parent
        console.log("Miaou ! ğŸ±");
    }
}
            </div>

            <h3>ğŸ”Œ Qu'est-ce qu'une Interface ?</h3>
            <div class="warning">
                <p><strong>Note :</strong> JavaScript ne supporte pas nativement les interfaces, mais on peut les simuler ou utiliser TypeScript.</p>
            </div>
            
            <p>Une interface dÃ©finit un <strong>contrat</strong> - elle spÃ©cifie quelles mÃ©thodes une classe doit implÃ©menter sans fournir l'implÃ©mentation.</p>
            
            <div class="code-block">
// Simulation d'interface en JavaScript
class IVolable {
    voler() {
        throw new Error("La mÃ©thode voler() doit Ãªtre implÃ©mentÃ©e");
    }
    
    atterrir() {
        throw new Error("La mÃ©thode atterrir() doit Ãªtre implÃ©mentÃ©e");
    }
}

// Classe qui "implÃ©mente" l'interface
class Oiseau extends IVolable {
    constructor(espece) {
        super();
        this.espece = espece;
    }
    
    voler() {
        console.log(`ğŸ¦… L'${this.espece} vole gracieusement`);
    }
    
    atterrir() {
        console.log(`ğŸ›¬ L'${this.espece} atterrit`);
    }
}

class Avion extends IVolable {
    voler() {
        console.log("âœˆï¸ L'avion dÃ©colle !");
    }
    
    atterrir() {
        console.log("ğŸ›¬ Atterrissage rÃ©ussi !");
    }
}
            </div>

            <h3>ğŸ¯ IntÃ©rÃªt des Interfaces</h3>
            <ul>
                <li>ğŸ“ <strong>Contrat clair</strong> : DÃ©finit ce qu'une classe doit faire</li>
                <li>ğŸ”„ <strong>Polymorphisme</strong> : Plusieurs classes peuvent implÃ©menter la mÃªme interface</li>
                <li>ğŸ§¹ <strong>Code propre</strong> : SÃ©pare la dÃ©finition de l'implÃ©mentation</li>
                <li>ğŸ› ï¸ <strong>Maintenance</strong> : Facilite les modifications et tests</li>
            </ul>

            <h3>ğŸ†š Interface vs Classe Abstraite</h3>
            <div class="code-block">
/*
INTERFACE :
- DÃ©finit SEULEMENT le contrat (quoi faire)
- Aucune implÃ©mentation
- Une classe peut implÃ©menter plusieurs interfaces
- Plus flexible

CLASSE ABSTRAITE :
- Peut contenir du code commun (comment faire)
- MÃ©lange de mÃ©thodes implÃ©mentÃ©es et abstraites
- HÃ©ritage simple seulement
- Partage de code entre classes similaires
*/
            </div>
        </section>

        <section id="relations">
            <h2>ğŸ”— Relations entre Objets (UML)</h2>
            
            <h3>ğŸ¤ Association</h3>
            <p>Relation <strong>"utilise"</strong> - Un objet utilise un autre objet sans le possÃ©der.</p>
            
            <div class="code-block">
class Conducteur {
    constructor(nom, permis) {
        this.nom = nom;
        this.permis = permis;
    }
    
    conduire(voiture) {
        console.log(`${this.nom} conduit la ${voiture.getInfo()}`);
    }
}

class VoitureLocation {
    constructor(modele, immatriculation) {
        this.modele = modele;
        this.immatriculation = immatriculation;
    }
    
    getInfo() {
        return `${this.modele} (${this.immatriculation})`;
    }
}

// Association : le conducteur UTILISE la voiture
const pierre = new Conducteur("Pierre", "B123456");
const voitureDeLocation = new VoitureLocation("Peugeot 208", "AB-123-CD");

pierre.conduire(voitureDeLocation); // Pierre utilise la voiture
// Si Pierre disparaÃ®t, la voiture existe toujours !
            </div>

            <h3>ğŸ¢ AgrÃ©gation</h3>
            <p>Relation <strong>"a un"</strong> - Un objet contient d'autres objets qui peuvent exister indÃ©pendamment.</p>
            
            <div class="code-block">
class Employe {
    constructor(nom, poste) {
        this.nom = nom;
        this.poste = poste;
    }
}

class Entreprise {
    constructor(nom) {
        this.nom = nom;
        this.employes = []; // AgrÃ©gation : l'entreprise "a" des employÃ©s
    }
    
    embaucher(employe) {
        this.employes.push(employe);
        console.log(`âœ… ${employe.nom} a rejoint ${this.nom}`);
    }
    
    licencier(employe) {
        const index = this.employes.indexOf(employe);
        if (index > -1) {
            this.employes.splice(index, 1);
            console.log(`âŒ ${employe.nom} a quittÃ© ${this.nom}`);
        }
    }
}

const alice = new Employe("Alice", "DÃ©veloppeuse");
const bob = new Employe("Bob", "Designer");
const techCorp = new Entreprise("TechCorp");

techCorp.embaucher(alice);
techCorp.embaucher(bob);
// Si l'entreprise ferme, Alice et Bob existent toujours !
            </div>

            <h3>ğŸ—ï¸ Composition</h3>
            <p>Relation <strong>"est composÃ© de"</strong> - Un objet possÃ¨de complÃ¨tement d'autres objets qui ne peuvent pas exister sans lui.</p>
            
            <div class="code-block">
class Chambre {
    constructor(nom, superficie) {
        this.nom = nom;
        this.superficie = superficie;
    }
}

class Maison {
    constructor(adresse) {
        this.adresse = adresse;
        // Composition : la maison POSSÃˆDE des chambres
        this.chambres = [
            new Chambre("Salon", 30),
            new Chambre("Cuisine", 15),
            new Chambre("Chambre principale", 20)
        ];
    }
    
    ajouterChambre(nom, superficie) {
        const nouvelleChambre = new Chambre(nom, superficie);
        this.chambres.push(nouvelleChambre);
        return nouvelleChambre;
    }
    
    getSuperficieTotale() {
        return this.chambres.reduce((total, chambre) => total + chambre.superficie, 0);
    }
}

const maMaison = new Maison("123 Rue de la Paix");
console.log(`Superficie totale: ${maMaison.getSuperficieTotale()} mÂ²`);

// Si la maison est dÃ©truite, toutes ses chambres disparaissent aussi !
// Une chambre ne peut pas exister sans sa maison
            </div>

            <div class="important">
                <p><strong>RÃ©sumÃ© des relations :</strong></p>
                <ul>
                    <li>ğŸ¤ <strong>Association</strong> : "utilise" - indÃ©pendance complÃ¨te</li>
                    <li>ğŸ¢ <strong>AgrÃ©gation</strong> : "a un" - les parties peuvent survivre au tout</li>
                    <li>ğŸ—ï¸ <strong>Composition</strong> : "est composÃ© de" - les parties meurent avec le tout</li>
                </ul>
            </div>
        </section>

        <section id="polymorphisme">
            <h2>ğŸ­ Polymorphisme</h2>
            
            <h3>ğŸ¯ Ã€ quoi sert le Polymorphisme ?</h3>
            <p>Le polymorphisme permet Ã  <span class="highlight">diffÃ©rents objets</span> de rÃ©pondre Ã  la <span class="highlight">mÃªme interface</span> de maniÃ¨re diffÃ©rente. "Poly" = plusieurs, "morphe" = formes.</p>
            
            <div class="code-block">
// Interface commune via classe de base
